name: Deploy to Azure Container Apps

on:
  push:
    branches: [main]
  workflow_dispatch: {}

permissions:
  contents: read

env:
  # Azure resources (edit these once for your subscription)
  AZURE_LOCATION: australiaeast
  AZURE_RESOURCE_GROUP: wealthtracker-rg
  AZURE_CONTAINERAPPS_ENV: wealthtracker-env

  # ACR name must be globally unique and contain only alphanumeric characters.
  # Example: wealthtrackeracr1234
  AZURE_ACR_NAME: wealthtrackeracr1234

  # Container App names
  API_APP_NAME: wealthtracker-api
  WEB_APP_NAME: wealthtracker-web
  MARKETDATA_APP_NAME: wealthtracker-market-data

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Azure login
        uses: azure/login@v2
        with:
          creds: ${{ secrets.AZURE_CREDENTIALS }}

      - name: Ensure Azure providers + extension
        shell: bash
        run: |
          set -euo pipefail
          az extension add --name containerapp --upgrade --allow-preview true

          # Provider registration is a one-time, subscription-level operation.
          # If your GitHub Service Principal is scoped only to a Resource Group (recommended),
          # it will NOT have permission to register providers. In that case, register once
          # manually (Azure Portal or `az provider register ...`) and rerun the workflow.
          missing=0
          for ns in Microsoft.App Microsoft.OperationalInsights Microsoft.ContainerRegistry; do
            state="$(az provider show --namespace "$ns" --query registrationState -o tsv 2>/dev/null || true)"
            if [ "$state" != "Registered" ]; then
              echo "::error title=Azure provider not registered::$ns registrationState=$state"
              missing=1
            fi
          done

          if [ "$missing" -ne 0 ]; then
            cat <<'EOF'
          One or more Azure Resource Providers are not registered in this subscription.

          Fix (run once with an account that has subscription-level permission):
            az provider register --namespace Microsoft.App --wait
            az provider register --namespace Microsoft.OperationalInsights --wait
            az provider register --namespace Microsoft.ContainerRegistry --wait

          Portal alternative:
            Azure Portal -> Subscriptions -> (your subscription) -> Resource providers -> search + Register.
          EOF
            exit 1
          fi

      - name: Provision resource group, ACR, and Container Apps environment
        shell: bash
        run: |
          set -euo pipefail

          az group create -n "$AZURE_RESOURCE_GROUP" -l "$AZURE_LOCATION" >/dev/null

          if ! az acr show -n "$AZURE_ACR_NAME" -g "$AZURE_RESOURCE_GROUP" >/dev/null 2>&1; then
            az acr create \
              -n "$AZURE_ACR_NAME" \
              -g "$AZURE_RESOURCE_GROUP" \
              -l "$AZURE_LOCATION" \
              --sku Basic \
              --admin-enabled true \
              >/dev/null
          else
            az acr update -n "$AZURE_ACR_NAME" --admin-enabled true >/dev/null
          fi

          if ! az containerapp env show -n "$AZURE_CONTAINERAPPS_ENV" -g "$AZURE_RESOURCE_GROUP" >/dev/null 2>&1; then
            az containerapp env create \
              -n "$AZURE_CONTAINERAPPS_ENV" \
              -g "$AZURE_RESOURCE_GROUP" \
              -l "$AZURE_LOCATION" \
              >/dev/null
          fi

          ACR_LOGIN_SERVER="$(az acr show -n "$AZURE_ACR_NAME" --query loginServer -o tsv)"
          ACR_USERNAME="$(az acr credential show -n "$AZURE_ACR_NAME" --query username -o tsv)"
          ACR_PASSWORD="$(az acr credential show -n "$AZURE_ACR_NAME" --query passwords[0].value -o tsv)"

          {
            echo "ACR_LOGIN_SERVER=$ACR_LOGIN_SERVER"
            echo "ACR_USERNAME=$ACR_USERNAME"
          } >> "$GITHUB_ENV"

          echo "::add-mask::$ACR_PASSWORD"
          echo "ACR_PASSWORD=$ACR_PASSWORD" >> "$GITHUB_ENV"

      - name: Docker login to ACR
        shell: bash
        run: |
          set -euo pipefail
          echo "$ACR_PASSWORD" | docker login "$ACR_LOGIN_SERVER" -u "$ACR_USERNAME" --password-stdin

      - name: Build and push images
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          set -euo pipefail

          docker build \
            -t "$ACR_LOGIN_SERVER/wealthtracker-api:$IMAGE_TAG" \
            -f WealthTrackerServer/Dockerfile \
            .
          docker push "$ACR_LOGIN_SERVER/wealthtracker-api:$IMAGE_TAG"

          docker build \
            -t "$ACR_LOGIN_SERVER/wealthtracker-web:$IMAGE_TAG" \
            -f WealthTrackerClient/Dockerfile \
            WealthTrackerClient
          docker push "$ACR_LOGIN_SERVER/wealthtracker-web:$IMAGE_TAG"

          docker build \
            -t "$ACR_LOGIN_SERVER/wealthtracker-market-data:$IMAGE_TAG" \
            -f MarketDataService/Dockerfile \
            MarketDataService
          docker push "$ACR_LOGIN_SERVER/wealthtracker-market-data:$IMAGE_TAG"

      - name: Retain last 5 images per repo (delete older)
        shell: bash
        run: |
          set -euo pipefail

          keep=5

          cleanup_repo () {
            local repo="$1"
            echo "Cleaning ACR repo: $repo (keep last $keep digests)"

            # Ordered newest -> oldest
            local manifests
            manifests="$(az acr repository show-manifests -n "$AZURE_ACR_NAME" --repository "$repo" --orderby time_desc -o json)"

            # 1) Remove all untagged manifests (safe, they are not directly rollbackable by tag).
            echo "$manifests" \
              | jq -r '.[] | select(.tags == null or (.tags | length) == 0) | .digest' \
              | while read -r digest; do
                  [ -z "$digest" ] && continue
                  az acr repository delete -n "$AZURE_ACR_NAME" --image "$repo@$digest" --yes >/dev/null
                done

            # 2) Keep only the last N unique digests (removes old tagged versions too).
            echo "$manifests" \
              | jq -r '.[].digest' \
              | awk '!seen[$0]++' \
              | tail -n +$((keep + 1)) \
              | while read -r digest; do
                  [ -z "$digest" ] && continue
                  az acr repository delete -n "$AZURE_ACR_NAME" --image "$repo@$digest" --yes >/dev/null
                done
          }

          cleanup_repo wealthtracker-api
          cleanup_repo wealthtracker-web
          cleanup_repo wealthtracker-market-data

      - name: Deploy market-data (internal)
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
          UPSTASH_REDIS_URL: ${{ secrets.UPSTASH_REDIS_URL }}
          UPSTASH_REDIS_REST_URL: ${{ secrets.UPSTASH_REDIS_REST_URL }}
          UPSTASH_REDIS_REST_TOKEN: ${{ secrets.UPSTASH_REDIS_REST_TOKEN }}
          CACHE_TTL_SECONDS: ${{ secrets.CACHE_TTL_SECONDS }}
        run: |
          set -euo pipefail

          REVISION_SUFFIX="${GITHUB_SHA::7}"
          IMAGE="$ACR_LOGIN_SERVER/wealthtracker-market-data:$IMAGE_TAG"

          CREATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$MARKETDATA_APP_NAME"
            --environment "$AZURE_CONTAINERAPPS_ENV"
            --image "$IMAGE"
            --registry-server "$ACR_LOGIN_SERVER"
            --registry-username "$ACR_USERNAME"
            --registry-password "$ACR_PASSWORD"
            --revision-suffix "$REVISION_SUFFIX"
            --revisions-mode multiple
            --max-inactive-revisions 4
            --ingress internal
            --target-port 8001
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          UPDATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$MARKETDATA_APP_NAME"
            --image "$IMAGE"
            --revision-suffix "$REVISION_SUFFIX"
            --max-inactive-revisions 4
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          ENV_VARS=(
            "PORT=8001"
            "REDIS_URL=$UPSTASH_REDIS_URL"
            "UPSTASH_REDIS_REST_URL=$UPSTASH_REDIS_REST_URL"
            "UPSTASH_REDIS_REST_TOKEN=$UPSTASH_REDIS_REST_TOKEN"
            "CACHE_TTL_SECONDS=${CACHE_TTL_SECONDS:-300}"
          )

          if az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$MARKETDATA_APP_NAME" >/dev/null 2>&1; then
            az containerapp update "${UPDATE_ARGS[@]}" --set-env-vars "${ENV_VARS[@]}" >/dev/null
          else
            az containerapp create "${CREATE_ARGS[@]}" --env-vars "${ENV_VARS[@]}" >/dev/null
          fi

      - name: Deploy API (public)
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
          NEON_CONNECTION_STRING: ${{ secrets.NEON_CONNECTION_STRING }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
          JWT_PRIVATE_KEY_PEM: ${{ secrets.JWT_PRIVATE_KEY_PEM }}
          JWT_PUBLIC_KEY_PEM: ${{ secrets.JWT_PUBLIC_KEY_PEM }}
        run: |
          set -euo pipefail

          REVISION_SUFFIX="${GITHUB_SHA::7}"
          IMAGE="$ACR_LOGIN_SERVER/wealthtracker-api:$IMAGE_TAG"
          MARKETDATA_BASE_URL="http://$MARKETDATA_APP_NAME"

          # Normalize PEM values so they are safe to pass via CLI args:
          # - if the GitHub secret is multi-line, convert newlines to literal "\n"
          # - if it's already one-line with "\n", leave it unchanged
          JWT_PRIVATE_ESCAPED="${JWT_PRIVATE_KEY_PEM//$'\r'/}"
          JWT_PRIVATE_ESCAPED="${JWT_PRIVATE_ESCAPED//$'\n'/\\n}"
          JWT_PUBLIC_ESCAPED="${JWT_PUBLIC_KEY_PEM//$'\r'/}"
          JWT_PUBLIC_ESCAPED="${JWT_PUBLIC_ESCAPED//$'\n'/\\n}"

          # Fail fast if the secrets look like file paths or non-PEM payloads.
          # The app expects actual PEM content (with BEGIN/END lines), not a path like "/app/keys/public.pem".
          if [[ "$JWT_PUBLIC_ESCAPED" != *"BEGIN PUBLIC KEY"* ]]; then
            echo "::error title=Invalid JWT_PUBLIC_KEY_PEM::Expected PEM content containing 'BEGIN PUBLIC KEY'. Do not set this to a file path."
            exit 1
          fi

          if [[ "$JWT_PRIVATE_ESCAPED" != *"BEGIN PRIVATE KEY"* && "$JWT_PRIVATE_ESCAPED" != *"BEGIN RSA PRIVATE KEY"* ]]; then
            echo "::error title=Invalid JWT_PRIVATE_KEY_PEM::Expected PEM content containing 'BEGIN PRIVATE KEY' or 'BEGIN RSA PRIVATE KEY'. Do not set this to a file path."
            exit 1
          fi

          CREATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$API_APP_NAME"
            --environment "$AZURE_CONTAINERAPPS_ENV"
            --image "$IMAGE"
            --registry-server "$ACR_LOGIN_SERVER"
            --registry-username "$ACR_USERNAME"
            --registry-password "$ACR_PASSWORD"
            --revision-suffix "$REVISION_SUFFIX"
            --revisions-mode multiple
            --max-inactive-revisions 4
            --ingress external
            --target-port 5141
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          UPDATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$API_APP_NAME"
            --image "$IMAGE"
            --revision-suffix "$REVISION_SUFFIX"
            --max-inactive-revisions 4
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          ENV_VARS=(
            "PORT=5141"
            "MIGRATE_ON_STARTUP=1"
            "FrontendUrl=https://example.com"
            "MarketDataService__BaseUrl=$MARKETDATA_BASE_URL"
            "ConnectionStrings__DefaultConnection=$NEON_CONNECTION_STRING"
            "Authentication__Google__ClientId=$GOOGLE_CLIENT_ID"
            "Authentication__Google__ClientSecret=$GOOGLE_CLIENT_SECRET"
            "Authentication__Google__RedirectUri=https://example.com/auth/callback"
            "Authentication__Jwt__Issuer=WealthTracker"
            "Authentication__Jwt__Audience=WealthTrackerApi"
            "Authentication__Jwt__AccessTokenExpirationMinutes=60"
            "Authentication__Jwt__RefreshTokenExpirationDays=7"
            "Authentication__Jwt__RsaPrivateKeyPem=$JWT_PRIVATE_ESCAPED"
            "Authentication__Jwt__RsaPublicKeyPem=$JWT_PUBLIC_ESCAPED"
          )

          if az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$API_APP_NAME" >/dev/null 2>&1; then
            az containerapp update "${UPDATE_ARGS[@]}" --set-env-vars "${ENV_VARS[@]}" >/dev/null
          else
            az containerapp create "${CREATE_ARGS[@]}" --env-vars "${ENV_VARS[@]}" >/dev/null
          fi

          API_FQDN="$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$API_APP_NAME" --query properties.configuration.ingress.fqdn -o tsv)"
          echo "API_FQDN=$API_FQDN" >> "$GITHUB_ENV"

      - name: Deploy web (public)
        shell: bash
        env:
          IMAGE_TAG: ${{ github.sha }}
          GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
          CACHE_TTL_SECONDS: ${{ secrets.CACHE_TTL_SECONDS }}
        run: |
          set -euo pipefail

          REVISION_SUFFIX="${GITHUB_SHA::7}"
          IMAGE="$ACR_LOGIN_SERVER/wealthtracker-web:$IMAGE_TAG"
          API_BASE_URL="https://$API_FQDN/api"

          CREATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$WEB_APP_NAME"
            --environment "$AZURE_CONTAINERAPPS_ENV"
            --image "$IMAGE"
            --registry-server "$ACR_LOGIN_SERVER"
            --registry-username "$ACR_USERNAME"
            --registry-password "$ACR_PASSWORD"
            --revision-suffix "$REVISION_SUFFIX"
            --revisions-mode multiple
            --max-inactive-revisions 4
            --ingress external
            --target-port 8080
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          UPDATE_ARGS=(
            -g "$AZURE_RESOURCE_GROUP"
            -n "$WEB_APP_NAME"
            --image "$IMAGE"
            --revision-suffix "$REVISION_SUFFIX"
            --max-inactive-revisions 4
            --min-replicas 0
            --max-replicas 1
            --cpu 0.25
            --memory 0.5Gi
          )

          ENV_VARS=(
            "PORT=8080"
            "API_BASE_URL=$API_BASE_URL"
            "GOOGLE_CLIENT_ID=$GOOGLE_CLIENT_ID"
            "GOOGLE_REDIRECT_URI=https://example.com/auth/callback"
            "SCANNER_REFRESH_SECONDS=${CACHE_TTL_SECONDS:-300}"
          )

          if az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$WEB_APP_NAME" >/dev/null 2>&1; then
            az containerapp update "${UPDATE_ARGS[@]}" --set-env-vars "${ENV_VARS[@]}" >/dev/null
          else
            az containerapp create "${CREATE_ARGS[@]}" --env-vars "${ENV_VARS[@]}" >/dev/null
          fi

          WEB_FQDN="$(az containerapp show -g "$AZURE_RESOURCE_GROUP" -n "$WEB_APP_NAME" --query properties.configuration.ingress.fqdn -o tsv)"
          echo "WEB_FQDN=$WEB_FQDN" >> "$GITHUB_ENV"

      - name: Finalize URLs (CORS + OAuth redirect URIs)
        shell: bash
        run: |
          set -euo pipefail

          WEB_URL="https://$WEB_FQDN"
          API_BASE_URL="https://$API_FQDN/api"

          az containerapp update \
            -g "$AZURE_RESOURCE_GROUP" \
            -n "$API_APP_NAME" \
            --set-env-vars \
              "FrontendUrl=$WEB_URL" \
              "Authentication__Google__RedirectUri=$WEB_URL/auth/callback" \
            >/dev/null

          az containerapp update \
            -g "$AZURE_RESOURCE_GROUP" \
            -n "$WEB_APP_NAME" \
            --set-env-vars \
              "API_BASE_URL=$API_BASE_URL" \
              "GOOGLE_REDIRECT_URI=$WEB_URL/auth/callback" \
            >/dev/null

          echo "Deployed:"
          echo "  Web: $WEB_URL"
          echo "  API: https://$API_FQDN"
